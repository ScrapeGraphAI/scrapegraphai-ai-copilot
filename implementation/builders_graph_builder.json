[
    {
        "prompt": "how is implemented graph_builder",
        "answer": "\"\"\" \nGraphBuilder Module\n\"\"\"\n\nfrom langchain_core.prompts import ChatPromptTemplate\nfrom langchain.chains import create_extraction_chain\nfrom ..models import OpenAI, Gemini\nfrom ..helpers import nodes_metadata, graph_schema\nfrom ..models.ernie import Ernie\n\n\nclass GraphBuilder:\n    \"\"\"\n    GraphBuilder is a dynamic tool for constructing web scraping graphs based on user prompts. \n    It utilizes a natural language understanding model to interpret user prompts and \n    automatically generates a graph configuration for scraping web content.\n\n    Attributes:\n        prompt (str): The user's natural language prompt for the scraping task.\n        llm (ChatOpenAI): An instance of the ChatOpenAI class configured \n        with the specified llm_config.\n        nodes_description (str): A string description of all available nodes and their arguments.\n        chain (LLMChain): The extraction chain responsible for \n        processing the prompt and creating the graph.\n\n    Methods:\n        build_graph(): Executes the graph creation process based on the user prompt \n        and returns the graph configuration.\n        convert_json_to_graphviz(json_data): Converts a JSON graph configuration \n        to a Graphviz object for visualization.\n\n    Args:\n        prompt (str): The user's natural language prompt describing the desired scraping operation.\n        url (str): The target URL from which data is to be scraped.\n        llm_config (dict): Configuration parameters for the \n            language model, where 'api_key' is mandatory, \n            and 'model_name', 'temperature', and 'streaming' can be optionally included.\n\n    Raises:\n        ValueError: If 'api_key' is not included in llm_config.\n    \"\"\"\n\n    def __init__(self, user_prompt: str, config: dict):\n        \"\"\"\n        Initializes the GraphBuilder with a user prompt and language model configuration.\n        \"\"\"\n        self.user_prompt = user_prompt\n        self.config = config\n        self.llm = self._create_llm(config[\"llm\"])\n        self.nodes_description = self._generate_nodes_description()\n        self.chain = self._create_extraction_chain()\n\n    def _create_llm(self, llm_config: dict):\n        \"\"\"\n        Creates an instance of the OpenAI class with the provided language model configuration.\n\n        Returns:\n            OpenAI: An instance of the OpenAI class.\n\n        Raises:\n            ValueError: If 'api_key' is not provided in llm_config.\n        \"\"\"\n        llm_defaults = {\n            \"temperature\": 0,\n            \"streaming\": True\n        }\n        # Update defaults with any LLM parameters that were provided\n        llm_params = {**llm_defaults, **llm_config}\n        if \"api_key\" not in llm_params:\n            raise ValueError(\"LLM configuration must include an 'api_key'.\")\n\n        # select the model based on the model name\n        if \"gpt-\" in llm_params[\"model\"]:\n            return OpenAI(llm_params)\n        elif \"gemini\" in llm_params[\"model\"]:\n            return Gemini(llm_params)\n        elif \"ernie\" in llm_params[\"model\"]:\n            return Ernie(llm_params)\n        raise ValueError(\"Model not supported\")\n\n    def _generate_nodes_description(self):\n        \"\"\"\n        Generates a string description of all available nodes and their arguments.\n\n        Returns:\n            str: A string description of all available nodes and their arguments.\n        \"\"\"\n\n        return \"\\n\".join([\n            f\"\"\"- {node}: {data[\"description\"]} (Type: {data[\"type\"]}, \n            Args: {\", \".join(data[\"args\"].keys())})\"\"\"\n            for node, data in nodes_metadata.items()\n        ])\n\n    def _create_extraction_chain(self):\n        \"\"\"\n        Creates an extraction chain for processing the user prompt and \n        generating the graph configuration.\n\n        Returns:\n            LLMChain: An instance of the LLMChain class.\n        \"\"\"\n\n        create_graph_prompt_template = \"\"\"\n        You are an AI that designs direct graphs for web scraping tasks. \n        Your goal is to create a web scraping pipeline that is efficient and tailored to the user's requirements. \n        You have access to a set of default nodes, each with specific capabilities:\n\n        {nodes_description}\n\n        Based on the user's input: \"{input}\", identify the essential nodes required for the task and suggest a graph configuration that outlines the flow between the chosen nodes.\n        \"\"\".format(nodes_description=self.nodes_description, input=\"{input}\")\n        extraction_prompt = ChatPromptTemplate.from_template(\n            create_graph_prompt_template)\n        return create_extraction_chain(prompt=extraction_prompt, schema=graph_schema, llm=self.llm)\n\n    def build_graph(self):\n        \"\"\"\n        Executes the graph creation process based on the user prompt and\n         returns the graph configuration.\n\n        Returns:\n            dict: A JSON representation of the graph configuration.\n        \"\"\"\n        return self.chain.invoke(self.user_prompt)\n\n    @staticmethod\n    def convert_json_to_graphviz(json_data, format: str = 'pdf'):\n        \"\"\"\n        Converts a JSON graph configuration to a Graphviz object for visualization.\n\n        Args:\n            json_data (dict): A JSON representation of the graph configuration.\n\n        Returns:\n            graphviz.Digraph: A Graphviz object representing the graph configuration.\n        \"\"\"\n        try:\n            import graphviz\n        except ImportError:\n            raise ImportError(\"The 'graphviz' library is required for this functionality. \"\n                              \"Please install it from 'https://graphviz.org/download/'.\")\n\n        graph = graphviz.Digraph(comment='ScrapeGraphAI Generated Graph', format=format,\n                                 node_attr={'color': 'lightblue2', 'style': 'filled'})\n\n        graph_config = json_data[\"text\"][0]\n\n        # Retrieve nodes, edges, and the entry point from the JSON data\n        nodes = graph_config.get('nodes', [])\n        edges = graph_config.get('edges', [])\n        entry_point = graph_config.get('entry_point')\n\n        # Add nodes to the graph\n        for node in nodes:\n            # If this node is the entry point, use a double circle to denote it\n            if node['node_name'] == entry_point:\n                graph.node(node['node_name'], shape='doublecircle')\n            else:\n                graph.node(node['node_name'])\n\n        # Add edges to the graph\n        for edge in edges:\n            # An edge could potentially have multiple 'to' nodes if it's from a conditional node\n            if isinstance(edge['to'], list):\n                for to_node in edge['to']:\n                    graph.edge(edge['from'], to_node)\n            else:\n                graph.edge(edge['from'], edge['to'])\n\n        return graph\n"
    }
]