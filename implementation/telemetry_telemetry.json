[
    {
        "prompt": "how is telemetry implemented in Scrapegraphai?",
        "answer": "\"\"\"\nThis module contains code that relates to sending ScrapeGraphAI usage telemetry.\n\nTo disable sending telemetry there are three ways:\n\n1. Set it to false programmatically in your driver:\n  >>> from scrapegraphai import telemetry\n  >>> telemetry.disable_telemetry()\n2. Set it to `false` in ~/.scrapegraphai.conf under `DEFAULT`\n  [DEFAULT]\n  telemetry_enabled = False\n3. Set SCRAPEGRAPHAI_TELEMETRY_ENABLED=false as an environment variable:\n  SCRAPEGRAPHAI_TELEMETRY_ENABLED=false python run.py\n  or:\n  export SCRAPEGRAPHAI_TELEMETRY_ENABLED=false\n\"\"\"\n\nimport configparser\nimport functools\nimport importlib.metadata\nimport json\nimport os\nimport platform\nimport threading\nimport logging\nimport uuid\nfrom typing import Callable, Dict\nfrom urllib import request\n\nVERSION = importlib.metadata.version(\"scrapegraphai\")\nSTR_VERSION = \".\".join([str(i) for i in VERSION])\nHOST = \"https://eu.i.posthog.com\"\nTRACK_URL = f\"{HOST}/capture/\"  # https://posthog.com/docs/api/post-only-endpoints\nAPI_KEY = \"phc_orsfU4aHhtpTSLVcUE2hdUkQDLM4OEQZndKGFBKMEtn\"\nTIMEOUT = 2\nDEFAULT_CONFIG_LOCATION = os.path.expanduser(\"~/.scrapegraphai.conf\")\n\n\nlogger = logging.getLogger(__name__)\n\n\ndef _load_config(config_location: str) -> configparser.ConfigParser:\n    config = configparser.ConfigParser()\n    try:\n        with open(config_location) as f:\n            config.read_file(f)\n    except Exception:\n        config[\"DEFAULT\"] = {}\n    else:\n        if \"DEFAULT\" not in config:\n            config[\"DEFAULT\"] = {}\n\n    if \"anonymous_id\" not in config[\"DEFAULT\"]:\n        config[\"DEFAULT\"][\"anonymous_id\"] = str(uuid.uuid4())\n        try:\n            with open(config_location, \"w\") as f:\n                config.write(f)\n        except Exception:\n            pass\n    return config\n\n\ndef _check_config_and_environ_for_telemetry_flag(\n    telemetry_default: bool, config_obj: configparser.ConfigParser\n) -> bool:\n    telemetry_enabled = telemetry_default\n    if \"telemetry_enabled\" in config_obj[\"DEFAULT\"]:\n        try:\n            telemetry_enabled = config_obj.getboolean(\"DEFAULT\", \"telemetry_enabled\")\n        except ValueError as e:\n            logger.debug(f\"Unable to parse value for `telemetry_enabled` from config. Encountered {e}\")\n    if os.environ.get(\"SCRAPEGRAPHAI_TELEMETRY_ENABLED\") is not None:\n        env_value = os.environ.get(\"SCRAPEGRAPHAI_TELEMETRY_ENABLED\")\n        config_obj[\"DEFAULT\"][\"telemetry_enabled\"] = env_value\n        try:\n            telemetry_enabled = config_obj.getboolean(\"DEFAULT\", \"telemetry_enabled\")\n        except ValueError as e:\n            logger.debug(f\"Unable to parse value for `SCRAPEGRAPHAI_TELEMETRY_ENABLED` from environment. Encountered {e}\")\n    return telemetry_enabled\n\n\nconfig = _load_config(DEFAULT_CONFIG_LOCATION)\ng_telemetry_enabled = _check_config_and_environ_for_telemetry_flag(True, config)\ng_anonymous_id = config[\"DEFAULT\"][\"anonymous_id\"]\ncall_counter = 0\nMAX_COUNT_SESSION = 1000\n\nBASE_PROPERTIES = {\n    \"os_type\": os.name,\n    \"os_version\": platform.platform(),\n    \"python_version\": f\"{platform.python_version()}/{platform.python_implementation()}\",\n    \"distinct_id\": g_anonymous_id,\n    \"scrapegraphai_version\": VERSION,\n    \"telemetry_version\": \"0.0.3\",\n}\n\n\ndef disable_telemetry():\n    global g_telemetry_enabled\n    g_telemetry_enabled = False\n\n\ndef is_telemetry_enabled() -> bool:\n    if g_telemetry_enabled:\n        global call_counter\n        if call_counter == 0:\n            logger.debug(\n                \"Note: ScrapeGraphAI collects anonymous usage data to improve the library. \"\n                \"You can disable telemetry by setting SCRAPEGRAPHAI_TELEMETRY_ENABLED=false or \"\n                \"by editing ~/.scrapegraphai.conf.\"\n            )\n        call_counter += 1\n        if call_counter > MAX_COUNT_SESSION:\n            return False\n        return True\n    else:\n        return False\n\n\ndef _send_event_json(event_json: dict):\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"Authorization\": f\"Bearer {API_KEY}\",\n        \"User-Agent\": f\"scrapegraphai/{STR_VERSION}\",\n    }\n    try:\n        data = json.dumps(event_json).encode()\n        req = request.Request(TRACK_URL, data=data, headers=headers)\n        with request.urlopen(req, timeout=TIMEOUT) as f:\n            res = f.read()\n            if f.code != 200:\n                raise RuntimeError(res)\n    except Exception as e:\n        logger.debug(f\"Failed to send telemetry data: {e}\")\n    else:\n        logger.debug(f\"Telemetry data sent: {data}\")\n\n\ndef send_event_json(event_json: dict):\n    if not g_telemetry_enabled:\n        raise RuntimeError(\"Telemetry tracking is disabled!\")\n    try:\n        th = threading.Thread(target=_send_event_json, args=(event_json,))\n        th.start()\n    except Exception as e:\n        logger.debug(f\"Failed to send telemetry data in a thread: {e}\")\n\n\ndef log_event(event: str, properties: Dict[str, any]):\n    if is_telemetry_enabled():\n        event_json = {\n            \"api_key\": API_KEY,\n            \"event\": event,\n            \"properties\": {**BASE_PROPERTIES, **properties},\n        }\n        send_event_json(event_json)\n\n\ndef log_graph_execution(graph_name: str, source: str, prompt:str, schema:dict, llm_model: str, embedder_model: str, source_type: str, execution_time: float, content: str = None, response: dict = None, error_node: str = None, exception: str = None, total_tokens: int = None):\n    properties = {\n        \"graph_name\": graph_name,\n        \"source\": source,\n        \"prompt\": prompt,\n        \"schema\": schema,\n        \"llm_model\": llm_model,\n        \"embedder_model\": embedder_model,\n        \"source_type\": source_type,\n        \"content\": content,\n        \"response\": response,\n        \"execution_time\": execution_time,\n        \"error_node\": error_node,\n        \"exception\": exception,\n        \"total_tokens\": total_tokens,\n        \"type\": \"community-library\"\n    }\n    log_event(\"graph_execution\", properties)\n\n\ndef capture_function_usage(call_fn: Callable) -> Callable:\n    @functools.wraps(call_fn)\n    def wrapped_fn(*args, **kwargs):\n        try:\n            return call_fn(*args, **kwargs)\n        finally:\n            if is_telemetry_enabled():\n                try:\n                    function_name = call_fn.__name__\n                    log_event(\"function_usage\", {\"function_name\": function_name})\n                except Exception as e:\n                    logger.debug(f\"Failed to send telemetry for function usage. Encountered: {e}\")\n    return wrapped_fn"
    }
]