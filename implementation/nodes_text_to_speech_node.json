[
    {
        "prompt": "how is text_to_speech_node implemented in Scrapegraphai?",
        "answer": "\"\"\"\nTextToSpeechNode Module\n\"\"\"\nfrom typing import List, Optional\nfrom ..utils.logging import get_logger\nfrom .base_node import BaseNode\n\nclass TextToSpeechNode(BaseNode):\n    \"\"\"\n    Converts text to speech using the specified text-to-speech model.\n\n    Attributes:\n        tts_model: An instance of the text-to-speech model client.\n        verbose (bool): A flag indicating whether to show print statements during execution.\n\n    Args:\n        input (str): Boolean expression defining the input keys needed from the state.\n        output (List[str]): List of output keys to be updated in the state.\n        node_config (dict): Additional configuration for the node.\n        node_name (str): The unique identifier name for the node, defaulting to \"TextToSpeech\".\n    \"\"\"\n\n    def __init__(\n        self,\n        input: str,\n        output: List[str],\n        node_config: Optional[dict] = None,\n        node_name: str = \"TextToSpeech\",\n    ):\n        super().__init__(node_name, \"node\", input, output, 1, node_config)\n\n        self.tts_model = node_config[\"tts_model\"]\n        self.verbose = (\n            False if node_config is None else node_config.get(\"verbose\", False)\n        )\n\n    def execute(self, state: dict) -> dict:\n        \"\"\"\n        Converts text to speech using the specified text-to-speech model.\n\n        Args:\n            state (dict): The current state of the graph. The input keys will be used to fetch the\n                            correct data types from the state.\n\n        Returns:\n            dict: The updated state with the output key containing the audio generated from the text.\n\n        Raises:\n            KeyError: If the input keys are not found in the state, indicating that the\n                        necessary information for generating the audio is missing.\n        \"\"\"\n\n        self.logger.info(f\"--- Executing {self.node_name} Node ---\")\n\n        # Interpret input keys based on the provided input expression\n        input_keys = self.get_input_keys(state)\n\n        # Fetching data from the state based on the input keys\n        input_data = [state[key] for key in input_keys]\n\n        # get the text to translate\n        text2translate = str(next(iter(input_data[0].values())))\n        # text2translate = str(input_data[0])\n\n        audio = self.tts_model.run(text2translate)\n\n        state.update({self.output[0]: audio})\n        return state\n"
    }
]