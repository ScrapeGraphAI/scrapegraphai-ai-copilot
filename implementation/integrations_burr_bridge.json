[
    {
        "prompt": "how is implemented burr_bridge",
        "answer": "\"\"\"\nBridge class to integrate Burr into ScrapeGraphAI graphs\n[Burr](https://github.com/DAGWorks-Inc/burr)\n\"\"\"\n\nimport re\nimport uuid\nfrom hashlib import md5\nfrom typing import Any, Dict, List, Tuple\nimport inspect\n\ntry:\n    import burr\nexcept ImportError:\n    raise ImportError(\"burr package is not installed. Please install it with 'pip install scrapegraphai[burr]'\")\n\nfrom burr import tracking\nfrom burr.core import Application, ApplicationBuilder, State, Action, default, ApplicationContext\nfrom burr.lifecycle import PostRunStepHook, PreRunStepHook\n\n\nclass PrintLnHook(PostRunStepHook, PreRunStepHook):\n    \"\"\"\n    Hook to print the action name before and after it is executed.\n    \"\"\"\n\n    def pre_run_step(self, *, state: \"State\", action: \"Action\", **future_kwargs: Any):\n        print(f\"Starting action: {action.name}\")\n\n    def post_run_step(self, *, state: \"State\", action: \"Action\", **future_kwargs: Any):\n        print(f\"Finishing action: {action.name}\")\n\n\nclass BurrNodeBridge(Action):\n    \"\"\"Bridge class to convert a base graph node to a Burr action.\n    This is nice because we can dynamically declare the inputs/outputs (and not rely on function-parsing).\n    \"\"\"\n\n    def __init__(self, node):\n        \"\"\"Instantiates a BurrNodeBridge object.\n        \"\"\"\n        super(BurrNodeBridge, self).__init__()\n        self.node = node\n\n    @property\n    def reads(self) -> list[str]:\n        return parse_boolean_expression(self.node.input)\n\n    def run(self, state: State, **run_kwargs) -> dict:\n        node_inputs = {key: state[key] for key in self.reads if key in state}\n        result_state = self.node.execute(node_inputs, **run_kwargs)\n        return result_state\n\n    @property\n    def writes(self) -> list[str]:\n        return self.node.output\n\n    def update(self, result: dict, state: State) -> State:\n        return state.update(**result)\n\n    def get_source(self) -> str:\n        return inspect.getsource(self.node.__class__)\n\n\ndef parse_boolean_expression(expression: str) -> List[str]:\n    \"\"\"\n    Parse a boolean expression to extract the keys used in the expression, without boolean operators.\n\n    Args:\n        expression (str): The boolean expression to parse.\n\n    Returns:\n        list: A list of unique keys used in the expression.\n    \"\"\"\n\n    # Use regular expression to extract all unique keys\n    keys = re.findall(r'\\w+', expression)\n    return list(set(keys))  # Remove duplicates\n\n\nclass BurrBridge:\n    \"\"\"\n    Bridge class to integrate Burr into ScrapeGraphAI graphs.\n\n    Args:\n        base_graph (BaseGraph): The base graph to convert to a Burr application.\n        burr_config (dict): Configuration parameters for the Burr application.\n\n    Attributes:\n        base_graph (BaseGraph): The base graph to convert to a Burr application.\n        burr_config (dict): Configuration parameters for the Burr application.\n        tracker (LocalTrackingClient): The tracking client for the Burr application.\n        app_instance_id (str): The instance ID for the Burr application.\n        burr_inputs (dict): The inputs for the Burr application.\n        burr_app (Application): The Burr application instance.\n\n    Example:\n        >>> burr_bridge = BurrBridge(base_graph, burr_config)\n        >>> result = burr_bridge.execute(initial_state={\"input_key\": \"input_value\"})\n    \"\"\"\n\n    def __init__(self, base_graph, burr_config):\n        self.base_graph = base_graph\n        self.burr_config = burr_config\n        self.project_name = burr_config.get(\"project_name\", \"scrapegraph: {}\")\n        self.app_instance_id = burr_config.get(\"app_instance_id\", \"default-instance\")\n        self.burr_inputs = burr_config.get(\"inputs\", {})\n        self.burr_app = None\n\n    def _initialize_burr_app(self, initial_state: Dict[str, Any] = None) -> Application:\n        \"\"\"\n        Initialize a Burr application from the base graph.\n\n        Args:\n            initial_state (dict): The initial state of the Burr application.\n\n        Returns:\n            Application: The Burr application instance.\n        \"\"\"\n        if initial_state is None:\n            initial_state = {}\n\n        actions = self._create_actions()\n        transitions = self._create_transitions()\n        hooks = [PrintLnHook()]\n        burr_state = State(initial_state)\n        application_context = ApplicationContext.get()\n        builder = (\n            ApplicationBuilder()\n            .with_actions(**actions)\n            .with_transitions(*transitions)\n            .with_entrypoint(self.base_graph.entry_point)\n            .with_state(**burr_state)\n            .with_identifiers(app_id=str(uuid.uuid4())) # TODO -- grab this from state\n            .with_hooks(*hooks)\n        )\n        if application_context is not None:\n            builder = (\n                builder\n                # if we're using a tracker, we want to copy it/pass in\n                .with_tracker(\n                    application_context.tracker.copy() if application_context.tracker is not None else None\n                )  # remember to do `copy()` here!\n                .with_spawning_parent(\n                    application_context.app_id,\n                    application_context.sequence_id,\n                    application_context.partition_key,\n                )\n            )\n        else:\n            # This is the case in which nothing is spawning it\n            # in this case, we want to create a new tracker from scratch\n            builder = builder.with_tracker(tracking.LocalTrackingClient(project=self.project_name))\n        return builder.build()\n\n    def _create_actions(self) -> Dict[str, Any]:\n        \"\"\"\n        Create Burr actions from the base graph nodes.\n\n        Returns:\n            dict: A dictionary of Burr actions with the node name as keys and the action functions as values.\n        \"\"\"\n\n        actions = {}\n        for node in self.base_graph.nodes:\n            action_func = BurrNodeBridge(node)\n            actions[node.node_name] = action_func\n        return actions\n\n    def _create_transitions(self) -> List[Tuple[str, str, Any]]:\n        \"\"\"\n        Create Burr transitions from the base graph edges.\n\n        Returns:\n            list: A list of tuples representing the transitions between Burr actions.\n        \"\"\"\n\n        transitions = []\n        for from_node, to_node in self.base_graph.edges.items():\n            transitions.append((from_node, to_node, default))\n        return transitions\n\n    def _convert_state_from_burr(self, burr_state: State) -> Dict[str, Any]:\n        \"\"\"\n        Convert a Burr state to a dictionary state.\n\n        Args:\n            burr_state (State): The Burr state to convert.\n\n        Returns:\n            dict: The dictionary state instance.\n        \"\"\"\n\n        state = {}\n        for key in burr_state.__dict__.keys():\n            state[key] = getattr(burr_state, key)\n        return state\n\n    def execute(self, initial_state: Dict[str, Any] = {}) -> Dict[str, Any]:\n        \"\"\"\n        Execute the Burr application with the given initial state.\n\n        Args:\n            initial_state (dict): The initial state to pass to the Burr application.\n\n        Returns:\n            dict: The final state of the Burr application.\n        \"\"\"\n\n        self.burr_app = self._initialize_burr_app(initial_state)\n\n        # TODO: to fix final nodes detection\n        final_nodes = [self.burr_app.graph.actions[-1].name]\n\n        last_action, result, final_state = self.burr_app.run(\n            halt_after=final_nodes,\n            inputs=self.burr_inputs\n        )\n\n        return self._convert_state_from_burr(final_state)\n"
    }
]