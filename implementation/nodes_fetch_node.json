[
    {
        "prompt": "how is fetch_node implemented in Scrapegraphai?",
        "answer": "\"\"\"\"\nFetchNode Module\n\"\"\"\n\nimport json\nfrom typing import List, Optional\nfrom langchain_openai import ChatOpenAI\nimport pandas as pd\nimport requests\nfrom langchain_community.document_loaders import PyPDFLoader\nfrom langchain_core.documents import Document\nfrom ..utils.cleanup_html import cleanup_html\nfrom ..docloaders import ChromiumLoader\nfrom ..docloaders.browser_base import browser_base_fetch\nfrom ..utils.convert_to_md import convert_to_md\nfrom ..utils.logging import get_logger\nfrom .base_node import BaseNode\n\n\n\"\"\"\"\nFetchNode Module\n\"\"\"\nclass FetchNode(BaseNode):\n    \"\"\"\n    A node responsible for fetching the HTML content of a specified URL and updating\n    the graph's state with this content. It uses ChromiumLoader to fetch\n    the content from a web page asynchronously (with proxy protection).\n\n    This node acts as a starting point in many scraping workflows, preparing the state\n    with the necessary HTML content for further processing by subsequent nodes in the graph.\n\n    Attributes:\n        headless (bool): A flag indicating whether the browser should run in headless mode.\n        verbose (bool): A flag indicating whether to print verbose output during execution.\n\n    Args:\n        input (str): Boolean expression defining the input keys needed from the state.\n        output (List[str]): List of output keys to be updated in the state.\n        node_config (Optional[dict]): Additional configuration for the node.\n        node_name (str): The unique identifier name for the node, defaulting to \"Fetch\".\n    \"\"\"\n\n    def __init__(\n        self,\n        input: str,\n        output: List[str],\n        node_config: Optional[dict] = None,\n        node_name: str = \"Fetch\",\n    ):\n        super().__init__(node_name, \"node\", input, output, 1, node_config)\n\n        self.headless = (\n            True if node_config is None else node_config.get(\"headless\", True)\n        )\n        self.verbose = (\n            False if node_config is None else node_config.get(\"verbose\", False)\n        )\n        self.use_soup = (\n            False if node_config is None else node_config.get(\"use_soup\", False)\n        )\n        self.loader_kwargs = (\n            {} if node_config is None else node_config.get(\"loader_kwargs\", {})\n        )\n        self.llm_model = (\n            {} if node_config is None else node_config.get(\"llm_model\", {})\n        )\n        self.force = (\n            False if node_config is None else node_config.get(\"force\", False)\n        )\n        self.script_creator = (\n            False if node_config is None else node_config.get(\"script_creator\", False)\n        )\n        self.openai_md_enabled = (\n            False if node_config is None else node_config.get(\"openai_md_enabled\", False)\n        )\n\n        self.cut = (\n            False if node_config is None else node_config.get(\"cut\", True)\n        )\n\n        self.browser_base = (\n            None if node_config is None else node_config.get(\"browser_base\")\n        )\n\n    def execute(self, state):\n        \"\"\"\n        Executes the node's logic to fetch HTML content from a specified URL and\n        update the state with this content.\n\n        Args:\n            state (dict): The current state of the graph. The input keys will be used\n                            to fetch the correct data types from the state.\n\n        Returns:\n            dict: The updated state with a new output key containing the fetched HTML content.\n\n        Raises:\n            KeyError: If the input key is not found in the state, indicating that the\n                    necessary information to perform the operation is missing.\n        \"\"\"\n\n        self.logger.info(f\"--- Executing {self.node_name} Node ---\")\n\n        # Interpret input keys based on the provided input expression\n        input_keys = self.get_input_keys(state)\n        # Fetching data from the state based on the input keys\n        input_data = [state[key] for key in input_keys]\n\n        source = input_data[0]\n        input_type = input_keys[0]\n        \n        handlers = {\n            \"json_dir\": self.handle_directory,\n            \"xml_dir\": self.handle_directory,\n            \"csv_dir\": self.handle_directory,\n            \"pdf_dir\": self.handle_directory,\n            \"md_dir\": self.handle_directory,\n            \"pdf\": self.handle_file,\n            \"csv\": self.handle_file,\n            \"json\": self.handle_file,\n            \"xml\": self.handle_file,\n            \"md\": self.handle_file,\n        }\n        \n        if input_type in handlers:\n            return handlers[input_type](state, input_type, source)\n        elif self.input == \"pdf_dir\":\n            return state\n        elif not source.startswith(\"http\"):\n            return self.handle_local_source(state, source)\n        else:\n            return self.handle_web_source(state, source)\n    \n    def handle_directory(self, state, input_type, source):\n        \"\"\"\n        Handles the directory by compressing the source document and updating the state.\n\n        Parameters:\n        state (dict): The current state of the graph.\n        input_type (str): The type of input being processed.\n        source (str): The source document to be compressed.\n\n        Returns:\n        dict: The updated state with the compressed document.\n        \"\"\"\n        \n        compressed_document = [\n            source\n        ]\n        state.update({self.output[0]: compressed_document})\n        return state\n\n    def handle_file(self, state, input_type, source):\n        \"\"\"\n        Loads the content of a file based on its input type.\n\n        Parameters:\n        state (dict): The current state of the graph.\n        input_type (str): The type of the input file (e.g., \"pdf\", \"csv\", \"json\", \"xml\", \"md\").\n        source (str): The path to the source file.\n\n        Returns:\n        dict: The updated state with the compressed document.\n\n        The function supports the following input types:\n        - \"pdf\": Uses PyPDFLoader to load the content of a PDF file.\n        - \"csv\": Reads the content of a CSV file using pandas and converts it to a string.\n        - \"json\": Loads the content of a JSON file.\n        - \"xml\": Reads the content of an XML file as a string.\n        - \"md\": Reads the content of a Markdown file as a string.\n        \"\"\"\n        \n        compressed_document = self.load_file_content(source, input_type)\n        \n        return self.update_state(state, compressed_document)\n        \n    def load_file_content(self, source, input_type):\n        \"\"\"\n        Loads the content of a file based on its input type.\n\n        Parameters:\n        source (str): The path to the source file.\n        input_type (str): The type of the input file (e.g., \"pdf\", \"csv\", \"json\", \"xml\", \"md\").\n\n        Returns:\n        list: A list containing a Document object with the loaded content and metadata.\n        \"\"\"\n        \n        if input_type == \"pdf\":\n            loader = PyPDFLoader(source)\n            return loader.load()\n        elif input_type == \"csv\":\n            return [Document(page_content=str(pd.read_csv(source)), metadata={\"source\": \"csv\"})]\n        elif input_type == \"json\":\n            with open(source, encoding=\"utf-8\") as f:\n                return [Document(page_content=str(json.load(f)), metadata={\"source\": \"json\"})]\n        elif input_type == \"xml\" or input_type == \"md\":\n            with open(source, \"r\", encoding=\"utf-8\") as f:\n                data = f.read()\n            return [Document(page_content=data, metadata={\"source\": input_type})]\n    \n    def handle_local_source(self, state, source):\n        \"\"\"\n        Handles the local source by fetching HTML content, optionally converting it to Markdown,\n        and updating the state.\n\n        Parameters:\n        state (dict): The current state of the graph.\n        source (str): The HTML content from the local source.\n\n        Returns:\n        dict: The updated state with the processed content.\n\n        Raises:\n        ValueError: If the source is empty or contains only whitespace.\n        \"\"\"\n    \n        self.logger.info(f\"--- (Fetching HTML from: {source}) ---\")\n        if not source.strip():\n            raise ValueError(\"No HTML body content found in the local source.\")\n        \n        parsed_content = source\n\n        if isinstance(self.llm_model, ChatOpenAI) and not self.script_creator or self.force and not self.script_creator:\n            parsed_content = convert_to_md(source)\n        else:\n            parsed_content = source\n\n        compressed_document = [\n            Document(page_content=parsed_content, metadata={\"source\": \"local_dir\"})\n        ]\n        \n        return self.update_state(state, compressed_document)\n    \n    def handle_web_source(self, state, source):\n        \"\"\"\n        Handles the web source by fetching HTML content from a URL, optionally converting it to Markdown,\n        and updating the state.\n\n        Parameters:\n        state (dict): The current state of the graph.\n        source (str): The URL of the web source to fetch HTML content from.\n\n        Returns:\n        dict: The updated state with the processed content.\n\n        Raises:\n        ValueError: If the fetched HTML content is empty or contains only whitespace.\n        \"\"\"\n        \n        self.logger.info(f\"--- (Fetching HTML from: {source}) ---\")\n        if self.use_soup:\n            response = requests.get(source)\n            if response.status_code == 200:\n                if not response.text.strip():\n                    raise ValueError(\"No HTML body content found in the response.\")\n\n                if not self.cut:\n                    parsed_content = cleanup_html(response, source)\n\n                if  (isinstance(self.llm_model, ChatOpenAI)\n                     and not self.script_creator) or (self.force and not self.script_creator):\n                    parsed_content = convert_to_md(source, input_data[0])\n\n                compressed_document = [Document(page_content=parsed_content)]\n            else:\n                self.logger.warning(\n                    f\"Failed to retrieve contents from the webpage at url: {source}\"\n                )\n        else:\n            loader_kwargs = {}\n\n            if self.node_config is not None:\n                loader_kwargs = self.node_config.get(\"loader_kwargs\", {})\n\n            if self.browser_base is not None:\n                data =  browser_base_fetch(self.browser_base.get(\"api_key\"),\n                                            self.browser_base.get(\"project_id\"), [source])\n\n                document = [Document(page_content=content,\n                                    metadata={\"source\": source}) for content in data]\n            else:\n                loader = ChromiumLoader([source], headless=self.headless, **loader_kwargs)\n                document = loader.load()\n\n            if not document or not document[0].page_content.strip():\n                raise ValueError(\"No HTML body content found in the document fetched by ChromiumLoader.\")\n            parsed_content = document[0].page_content\n\n            if  isinstance(self.llm_model, ChatOpenAI) and not self.script_creator or self.force and not self.script_creator and not self.openai_md_enabled:\n                parsed_content = convert_to_md(document[0].page_content, input_data[0])\n\n            compressed_document = [\n                Document(page_content=parsed_content, metadata={\"source\": \"html file\"})\n            ]\n        \n        return self.update_state(state, compressed_document)\n        \n    def update_state(self, state, compressed_document):\n        \"\"\"\n        Updates the state with the output data from the node.\n\n        Args:\n            state (dict): The current state of the graph.\n            compressed_document (List[Document]): The compressed document content fetched\n                                                    by the node.\n\n        Returns:\n            dict: The updated state with the output data.\n        \"\"\"\n        \n        state.update({self.output[0]: compressed_document,})\n        return state"
    }
]