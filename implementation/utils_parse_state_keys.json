[
    {
        "prompt": "how is parse_state_keys implemented in Scrapegraphai?",
        "answer": "\"\"\" \nParse_state_key module\n\"\"\"\nimport re\n\n\ndef parse_expression(expression, state: dict) -> list:\n    \"\"\"\n    Parses a complex boolean expression involving state keys.\n\n    Args:\n        expression (str): The boolean expression to parse.\n        state (dict): Dictionary of state keys used to evaluate the expression.\n\n    Raises:\n        ValueError: If the expression is empty, has adjacent state keys without operators, \n        invalid operator usage, unbalanced parentheses, or if no state keys match the expression.\n\n    Returns:\n        list: A list of state keys that match the boolean expression, \n        ensuring each key appears only once.\n\n    Example:\n        >>> parse_expression(\"user_input & (relevant_chunks | parsed_document | document)\", \n                            {\"user_input\": None, \"document\": None, \"parsed_document\": None, \"relevant_chunks\": None})\n        ['user_input', 'relevant_chunks', 'parsed_document', 'document']\n\n    This function evaluates the expression to determine the \n    logical inclusion of state keys based on provided boolean logic.\n    It checks for syntax errors such as unbalanced parentheses, \n    incorrect adjacency of operators, and empty expressions.\n    \"\"\"\n\n    # Check for empty expression\n    if not expression:\n        raise ValueError(\"Empty expression.\")\n\n    # Check for adjacent state keys without an operator between them\n    pattern = r'\\b(' + '|'.join(re.escape(key) for key in state.keys()) + \\\n        r')(\\b\\s*\\b)(' + '|'.join(re.escape(key)\n                                  for key in state.keys()) + r')\\b'\n    if re.search(pattern, expression):\n        raise ValueError(\n            \"Adjacent state keys found without an operator between them.\")\n\n    # Remove spaces\n    expression = expression.replace(\" \", \"\")\n\n    # Check for operators with empty adjacent tokens or at the start/end\n    if expression[0] in '&|' or expression[-1] in '&|' or \\\n        '&&' in expression or '||' in expression or \\\n            '&|' in expression or '|&' in expression:\n\n        raise ValueError(\"Invalid operator usage.\")\n\n    # Check for balanced parentheses and valid operator placement\n    open_parentheses = close_parentheses = 0\n    for i, char in enumerate(expression):\n        if char == '(':\n            open_parentheses += 1\n        elif char == ')':\n            close_parentheses += 1\n        # Check for invalid operator sequences\n        if char in \"&|\" and i + 1 < len(expression) and expression[i + 1] in \"&|\":\n            raise ValueError(\n                \"Invalid operator placement: operators cannot be adjacent.\")\n\n    # Check for missing or balanced parentheses\n    if open_parentheses != close_parentheses:\n        raise ValueError(\"Missing or unbalanced parentheses in expression.\")\n\n    # Helper function to evaluate an expression without parentheses\n    def evaluate_simple_expression(exp):\n        # Split the expression by the OR operator and process each segment\n        for or_segment in exp.split('|'):\n            # Check if all elements in an AND segment are in state\n            and_segment = or_segment.split('&')\n            if all(elem.strip() in state for elem in and_segment):\n                return [elem.strip() for elem in and_segment if elem.strip() in state]\n        return []\n\n    # Helper function to evaluate expressions with parentheses\n    def evaluate_expression(expression):\n        while '(' in expression:\n            start = expression.rfind('(')\n            end = expression.find(')', start)\n            sub_exp = expression[start + 1:end]\n            # Replace the evaluated part with a placeholder and then evaluate it\n            sub_result = evaluate_simple_expression(sub_exp)\n            # For simplicity in handling, join sub-results with OR to reprocess them later\n            expression = expression[:start] + \\\n                '|'.join(sub_result) + expression[end+1:]\n        return evaluate_simple_expression(expression)\n\n    temp_result = evaluate_expression(expression)\n\n    if not temp_result:\n        raise ValueError(\"No state keys matched the expression.\")\n\n    # Remove redundant state keys from the result, without changing their order\n    final_result = []\n    for key in temp_result:\n        if key not in final_result:\n            final_result.append(key)\n\n    return final_result\n"
    }
]